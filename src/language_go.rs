// Code generated; DO NOT EDIT.

#[derive(Clone, Debug, PartialEq)]
pub enum Go {
    End = 0,
    Identifier = 1,
    LF = 2,
    SEMI = 3,
    Package = 4,
    Import = 5,
    DOT = 6,
    BlankIdentifier = 7,
    LPAREN = 8,
    RPAREN = 9,
    Const = 10,
    COMMA = 11,
    EQ = 12,
    Var = 13,
    Func = 14,
    DOTDOTDOT = 15,
    Type = 16,
    STAR = 17,
    LBRACK = 18,
    RBRACK = 19,
    Struct = 20,
    LBRACE = 21,
    RBRACE = 22,
    Interface = 23,
    Map = 24,
    Chan = 25,
    LTDASH = 26,
    COLONEQ = 27,
    PLUSPLUS = 28,
    DASHDASH = 29,
    STAREQ = 30,
    SLASHEQ = 31,
    PERCENTEQ = 32,
    LTLTEQ = 33,
    GTGTEQ = 34,
    AMPEQ = 35,
    AMPCARETEQ = 36,
    PLUSEQ = 37,
    DASHEQ = 38,
    PIPEEQ = 39,
    CARETEQ = 40,
    COLON = 41,
    Fallthrough = 42,
    Break = 43,
    Continue = 44,
    Goto = 45,
    Return = 46,
    Go = 47,
    Defer = 48,
    If = 49,
    Else = 50,
    For = 51,
    Range = 52,
    Switch = 53,
    Case = 54,
    Default = 55,
    Select = 56,
    Identifier2 = 57,
    Identifier3 = 58,
    PLUS = 59,
    DASH = 60,
    BANG = 61,
    CARET = 62,
    AMP = 63,
    SLASH = 64,
    PERCENT = 65,
    LTLT = 66,
    GTGT = 67,
    AMPCARET = 68,
    PIPE = 69,
    EQEQ = 70,
    BANGEQ = 71,
    LT = 72,
    LTEQ = 73,
    GT = 74,
    GTEQ = 75,
    AMPAMP = 76,
    PIPEPIPE = 77,
    RawStringLiteral = 78,
    DQUOTE = 79,
    InterpretedStringLiteralToken1 = 80,
    EscapeSequence = 81,
    IntLiteral = 82,
    FloatLiteral = 83,
    ImaginaryLiteral = 84,
    RuneLiteral = 85,
    Nil = 86,
    True = 87,
    False = 88,
    Comment = 89,
    SourceFile = 90,
    PackageClause = 91,
    ImportDeclaration = 92,
    ImportSpec = 93,
    Dot = 94,
    ImportSpecList = 95,
    Declaration = 96,
    ConstDeclaration = 97,
    ConstSpec = 98,
    VarDeclaration = 99,
    VarSpec = 100,
    FunctionDeclaration = 101,
    MethodDeclaration = 102,
    ParameterList = 103,
    ParameterDeclaration = 104,
    VariadicParameterDeclaration = 105,
    TypeAlias = 106,
    TypeDeclaration = 107,
    TypeSpec = 108,
    ExpressionList = 109,
    ParenthesizedType = 110,
    SimpleType = 111,
    PointerType = 112,
    ArrayType = 113,
    ImplicitLengthArrayType = 114,
    SliceType = 115,
    StructType = 116,
    FieldDeclarationList = 117,
    FieldDeclaration = 118,
    InterfaceType = 119,
    MethodSpecList = 120,
    MethodSpec = 121,
    MapType = 122,
    ChannelType = 123,
    FunctionType = 124,
    Block = 125,
    StatementList = 126,
    Statement = 127,
    EmptyStatement = 128,
    SimpleStatement = 129,
    SendStatement = 130,
    ReceiveStatement = 131,
    IncStatement = 132,
    DecStatement = 133,
    AssignmentStatement = 134,
    ShortVarDeclaration = 135,
    LabeledStatement = 136,
    LabeledStatement2 = 137,
    FallthroughStatement = 138,
    BreakStatement = 139,
    ContinueStatement = 140,
    GotoStatement = 141,
    ReturnStatement = 142,
    GoStatement = 143,
    DeferStatement = 144,
    IfStatement = 145,
    IfInitializer = 146,
    ElseClause = 147,
    ForStatement = 148,
    ForClause = 149,
    RangeClause = 150,
    ExpressionSwitchStatement = 151,
    ExpressionCaseClause = 152,
    ExpressionCase = 153,
    DefaultCase = 154,
    TypeSwitchStatement = 155,
    TypeSwitchGuard = 156,
    TypeCaseClause = 157,
    TypeCase = 158,
    SelectStatement = 159,
    CommunicationClause = 160,
    CommunicationCase = 161,
    Expression = 162,
    ParenthesizedExpression = 163,
    CallExpression = 164,
    VariadicArgument = 165,
    ArgumentList = 166,
    ArgumentList2 = 167,
    SelectorExpression = 168,
    IndexExpression = 169,
    SliceExpression = 170,
    TypeAssertionExpression = 171,
    TypeConversionExpression = 172,
    CompositeLiteral = 173,
    LiteralValue = 174,
    KeyedElement = 175,
    Element = 176,
    FuncLiteral = 177,
    UnaryExpression = 178,
    BinaryExpression = 179,
    QualifiedType = 180,
    StringLiteral = 181,
    InterpretedStringLiteral = 182,
    SourceFileRepeat1 = 183,
    ImportSpecListRepeat1 = 184,
    ConstDeclarationRepeat1 = 185,
    ConstSpecRepeat1 = 186,
    VarDeclarationRepeat1 = 187,
    ParameterListRepeat1 = 188,
    TypeDeclarationRepeat1 = 189,
    FieldNameListRepeat1 = 190,
    ExpressionListRepeat1 = 191,
    FieldDeclarationListRepeat1 = 192,
    MethodSpecListRepeat1 = 193,
    StatementListRepeat1 = 194,
    ExpressionSwitchStatementRepeat1 = 195,
    TypeSwitchStatementRepeat1 = 196,
    TypeCaseRepeat1 = 197,
    SelectStatementRepeat1 = 198,
    ArgumentListRepeat1 = 199,
    LiteralValueRepeat1 = 200,
    InterpretedStringLiteralRepeat1 = 201,
    PackageIdentifier = 202,
    FieldIdentifier = 203,
    LabelName = 204,
    TypeIdentifier = 205,
    Error = 206,
}

impl Into<&'static str> for Go {
    fn into(self) -> &'static str {
        match self {
            Go::End => "end",
            Go::Identifier => "identifier",
            Go::LF => "\n",
            Go::SEMI => ";",
            Go::Package => "package",
            Go::Import => "import",
            Go::DOT => ".",
            Go::BlankIdentifier => "blank_identifier",
            Go::LPAREN => "(",
            Go::RPAREN => ")",
            Go::Const => "const",
            Go::COMMA => ",",
            Go::EQ => "=",
            Go::Var => "var",
            Go::Func => "func",
            Go::DOTDOTDOT => "...",
            Go::Type => "type",
            Go::STAR => "*",
            Go::LBRACK => "[",
            Go::RBRACK => "]",
            Go::Struct => "struct",
            Go::LBRACE => "{",
            Go::RBRACE => "}",
            Go::Interface => "interface",
            Go::Map => "map",
            Go::Chan => "chan",
            Go::LTDASH => "<-",
            Go::COLONEQ => ":=",
            Go::PLUSPLUS => "++",
            Go::DASHDASH => "--",
            Go::STAREQ => "*=",
            Go::SLASHEQ => "/=",
            Go::PERCENTEQ => "%=",
            Go::LTLTEQ => "<<=",
            Go::GTGTEQ => ">>=",
            Go::AMPEQ => "&=",
            Go::AMPCARETEQ => "&^=",
            Go::PLUSEQ => "+=",
            Go::DASHEQ => "-=",
            Go::PIPEEQ => "|=",
            Go::CARETEQ => "^=",
            Go::COLON => ":",
            Go::Fallthrough => "fallthrough",
            Go::Break => "break",
            Go::Continue => "continue",
            Go::Goto => "goto",
            Go::Return => "return",
            Go::Go => "go",
            Go::Defer => "defer",
            Go::If => "if",
            Go::Else => "else",
            Go::For => "for",
            Go::Range => "range",
            Go::Switch => "switch",
            Go::Case => "case",
            Go::Default => "default",
            Go::Select => "select",
            Go::Identifier2 => "identifier",
            Go::Identifier3 => "identifier",
            Go::PLUS => "+",
            Go::DASH => "-",
            Go::BANG => "!",
            Go::CARET => "^",
            Go::AMP => "&",
            Go::SLASH => "/",
            Go::PERCENT => "%",
            Go::LTLT => "<<",
            Go::GTGT => ">>",
            Go::AMPCARET => "&^",
            Go::PIPE => "|",
            Go::EQEQ => "==",
            Go::BANGEQ => "!=",
            Go::LT => "<",
            Go::LTEQ => "<=",
            Go::GT => ">",
            Go::GTEQ => ">=",
            Go::AMPAMP => "&&",
            Go::PIPEPIPE => "||",
            Go::RawStringLiteral => "raw_string_literal",
            Go::DQUOTE => "\"",
            Go::InterpretedStringLiteralToken1 => "interpreted_string_literal_token1",
            Go::EscapeSequence => "escape_sequence",
            Go::IntLiteral => "int_literal",
            Go::FloatLiteral => "float_literal",
            Go::ImaginaryLiteral => "imaginary_literal",
            Go::RuneLiteral => "rune_literal",
            Go::Nil => "nil",
            Go::True => "true",
            Go::False => "false",
            Go::Comment => "comment",
            Go::SourceFile => "source_file",
            Go::PackageClause => "package_clause",
            Go::ImportDeclaration => "import_declaration",
            Go::ImportSpec => "import_spec",
            Go::Dot => "dot",
            Go::ImportSpecList => "import_spec_list",
            Go::Declaration => "_declaration",
            Go::ConstDeclaration => "const_declaration",
            Go::ConstSpec => "const_spec",
            Go::VarDeclaration => "var_declaration",
            Go::VarSpec => "var_spec",
            Go::FunctionDeclaration => "function_declaration",
            Go::MethodDeclaration => "method_declaration",
            Go::ParameterList => "parameter_list",
            Go::ParameterDeclaration => "parameter_declaration",
            Go::VariadicParameterDeclaration => "variadic_parameter_declaration",
            Go::TypeAlias => "type_alias",
            Go::TypeDeclaration => "type_declaration",
            Go::TypeSpec => "type_spec",
            Go::ExpressionList => "expression_list",
            Go::ParenthesizedType => "parenthesized_type",
            Go::SimpleType => "_simple_type",
            Go::PointerType => "pointer_type",
            Go::ArrayType => "array_type",
            Go::ImplicitLengthArrayType => "implicit_length_array_type",
            Go::SliceType => "slice_type",
            Go::StructType => "struct_type",
            Go::FieldDeclarationList => "field_declaration_list",
            Go::FieldDeclaration => "field_declaration",
            Go::InterfaceType => "interface_type",
            Go::MethodSpecList => "method_spec_list",
            Go::MethodSpec => "method_spec",
            Go::MapType => "map_type",
            Go::ChannelType => "channel_type",
            Go::FunctionType => "function_type",
            Go::Block => "block",
            Go::StatementList => "_statement_list",
            Go::Statement => "_statement",
            Go::EmptyStatement => "empty_statement",
            Go::SimpleStatement => "_simple_statement",
            Go::SendStatement => "send_statement",
            Go::ReceiveStatement => "receive_statement",
            Go::IncStatement => "inc_statement",
            Go::DecStatement => "dec_statement",
            Go::AssignmentStatement => "assignment_statement",
            Go::ShortVarDeclaration => "short_var_declaration",
            Go::LabeledStatement => "labeled_statement",
            Go::LabeledStatement2 => "labeled_statement",
            Go::FallthroughStatement => "fallthrough_statement",
            Go::BreakStatement => "break_statement",
            Go::ContinueStatement => "continue_statement",
            Go::GotoStatement => "goto_statement",
            Go::ReturnStatement => "return_statement",
            Go::GoStatement => "go_statement",
            Go::DeferStatement => "defer_statement",
            Go::IfStatement => "if_statement",
            Go::IfInitializer => "if_initializer",
            Go::ElseClause => "else_clause",
            Go::ForStatement => "for_statement",
            Go::ForClause => "for_clause",
            Go::RangeClause => "range_clause",
            Go::ExpressionSwitchStatement => "expression_switch_statement",
            Go::ExpressionCaseClause => "expression_case_clause",
            Go::ExpressionCase => "expression_case",
            Go::DefaultCase => "default_case",
            Go::TypeSwitchStatement => "type_switch_statement",
            Go::TypeSwitchGuard => "type_switch_guard",
            Go::TypeCaseClause => "type_case_clause",
            Go::TypeCase => "type_case",
            Go::SelectStatement => "select_statement",
            Go::CommunicationClause => "communication_clause",
            Go::CommunicationCase => "communication_case",
            Go::Expression => "_expression",
            Go::ParenthesizedExpression => "parenthesized_expression",
            Go::CallExpression => "call_expression",
            Go::VariadicArgument => "variadic_argument",
            Go::ArgumentList => "argument_list",
            Go::ArgumentList2 => "argument_list",
            Go::SelectorExpression => "selector_expression",
            Go::IndexExpression => "index_expression",
            Go::SliceExpression => "slice_expression",
            Go::TypeAssertionExpression => "type_assertion_expression",
            Go::TypeConversionExpression => "type_conversion_expression",
            Go::CompositeLiteral => "composite_literal",
            Go::LiteralValue => "literal_value",
            Go::KeyedElement => "keyed_element",
            Go::Element => "element",
            Go::FuncLiteral => "func_literal",
            Go::UnaryExpression => "unary_expression",
            Go::BinaryExpression => "binary_expression",
            Go::QualifiedType => "qualified_type",
            Go::StringLiteral => "_string_literal",
            Go::InterpretedStringLiteral => "interpreted_string_literal",
            Go::SourceFileRepeat1 => "source_file_repeat1",
            Go::ImportSpecListRepeat1 => "import_spec_list_repeat1",
            Go::ConstDeclarationRepeat1 => "const_declaration_repeat1",
            Go::ConstSpecRepeat1 => "const_spec_repeat1",
            Go::VarDeclarationRepeat1 => "var_declaration_repeat1",
            Go::ParameterListRepeat1 => "parameter_list_repeat1",
            Go::TypeDeclarationRepeat1 => "type_declaration_repeat1",
            Go::FieldNameListRepeat1 => "field_name_list_repeat1",
            Go::ExpressionListRepeat1 => "expression_list_repeat1",
            Go::FieldDeclarationListRepeat1 => "field_declaration_list_repeat1",
            Go::MethodSpecListRepeat1 => "method_spec_list_repeat1",
            Go::StatementListRepeat1 => "_statement_list_repeat1",
            Go::ExpressionSwitchStatementRepeat1 => "expression_switch_statement_repeat1",
            Go::TypeSwitchStatementRepeat1 => "type_switch_statement_repeat1",
            Go::TypeCaseRepeat1 => "type_case_repeat1",
            Go::SelectStatementRepeat1 => "select_statement_repeat1",
            Go::ArgumentListRepeat1 => "argument_list_repeat1",
            Go::LiteralValueRepeat1 => "literal_value_repeat1",
            Go::InterpretedStringLiteralRepeat1 => "interpreted_string_literal_repeat1",
            Go::PackageIdentifier => "package_identifier",
            Go::FieldIdentifier => "field_identifier",
            Go::LabelName => "label_name",
            Go::TypeIdentifier => "type_identifier",
            Go::Error => "ERROR",
        }
    }
}

#[allow(clippy::unreadable_literal)]
static KEYS: phf::Map<&'static str, Go> = ::phf::Map {
    key: 3213172566270843353,
    disps: ::phf::Slice::Static(&[
        (1, 0),
        (0, 92),
        (1, 188),
        (0, 7),
        (6, 103),
        (0, 23),
        (0, 58),
        (0, 4),
        (0, 111),
        (0, 131),
        (0, 133),
        (0, 160),
        (2, 31),
        (22, 170),
        (0, 88),
        (0, 6),
        (114, 118),
        (0, 7),
        (0, 41),
        (0, 35),
        (12, 101),
        (0, 0),
        (0, 173),
        (0, 8),
        (0, 164),
        (18, 150),
        (1, 80),
        (0, 19),
        (0, 28),
        (0, 3),
        (0, 2),
        (0, 54),
        (0, 66),
        (0, 39),
        (29, 98),
        (1, 0),
        (1, 40),
        (0, 7),
        (9, 28),
        (0, 142),
        (99, 27),
    ]),
    entries: ::phf::Slice::Static(&[
        ("struct_type", Go::StructType),
        ("_simple_statement", Go::SimpleStatement),
        ("defer_statement", Go::DeferStatement),
        ("if", Go::If),
        ("var", Go::Var),
        ("range", Go::Range),
        ("ERROR", Go::Error),
        ("else_clause", Go::ElseClause),
        ("block", Go::Block),
        ("slice_expression", Go::SliceExpression),
        (
            "variadic_parameter_declaration",
            Go::VariadicParameterDeclaration,
        ),
        (">=", Go::GTEQ),
        ("interface", Go::Interface),
        ("assignment_statement", Go::AssignmentStatement),
        ("return_statement", Go::ReturnStatement),
        ("]", Go::RBRACK),
        ("type_case_repeat1", Go::TypeCaseRepeat1),
        ("composite_literal", Go::CompositeLiteral),
        ("nil", Go::Nil),
        (":=", Go::COLONEQ),
        ("if_statement", Go::IfStatement),
        ("blank_identifier", Go::BlankIdentifier),
        ("field_identifier", Go::FieldIdentifier),
        ("type_alias", Go::TypeAlias),
        ("\\n", Go::LF),
        (")", Go::RPAREN),
        ("interface_type", Go::InterfaceType),
        ("method_declaration", Go::MethodDeclaration),
        (
            "interpreted_string_literal_token1",
            Go::InterpretedStringLiteralToken1,
        ),
        ("expression_list_repeat1", Go::ExpressionListRepeat1),
        ("range_clause", Go::RangeClause),
        ("goto", Go::Goto),
        ("/", Go::SLASH),
        ("type_assertion_expression", Go::TypeAssertionExpression),
        ("-=", Go::DASHEQ),
        ("end", Go::End),
        ("source_file", Go::SourceFile),
        ("send_statement", Go::SendStatement),
        ("(", Go::LPAREN),
        ("short_var_declaration", Go::ShortVarDeclaration),
        ("element", Go::Element),
        ("import_spec_list", Go::ImportSpecList),
        ("unary_expression", Go::UnaryExpression),
        ("keyed_element", Go::KeyedElement),
        ("import", Go::Import),
        ("_expression", Go::Expression),
        ("raw_string_literal", Go::RawStringLiteral),
        ("_statement_list", Go::StatementList),
        ("expression_list", Go::ExpressionList),
        ("inc_statement", Go::IncStatement),
        ("type_switch_guard", Go::TypeSwitchGuard),
        ("\\\"", Go::DQUOTE),
        ("select_statement_repeat1", Go::SelectStatementRepeat1),
        ("map", Go::Map),
        ("<=", Go::LTEQ),
        ("array_type", Go::ArrayType),
        ("float_literal", Go::FloatLiteral),
        ("method_spec_list", Go::MethodSpecList),
        ("select_statement", Go::SelectStatement),
        ("goto_statement", Go::GotoStatement),
        ("default_case", Go::DefaultCase),
        ("rune_literal", Go::RuneLiteral),
        ("&", Go::AMP),
        ("func", Go::Func),
        ("select", Go::Select),
        (".", Go::DOT),
        ("true", Go::True),
        ("expression_case_clause", Go::ExpressionCaseClause),
        ("dec_statement", Go::DecStatement),
        ("argument_list", Go::ArgumentList),
        ("method_spec_list_repeat1", Go::MethodSpecListRepeat1),
        ("<<=", Go::LTLTEQ),
        ("&^=", Go::AMPCARETEQ),
        ("struct", Go::Struct),
        ("argument_list_repeat1", Go::ArgumentListRepeat1),
        ("for", Go::For),
        ("type_identifier", Go::TypeIdentifier),
        ("for_clause", Go::ForClause),
        ("false", Go::False),
        ("var_spec", Go::VarSpec),
        (">>", Go::GTGT),
        ("qualified_type", Go::QualifiedType),
        ("%", Go::PERCENT),
        (":", Go::COLON),
        ("comment", Go::Comment),
        ("binary_expression", Go::BinaryExpression),
        ("/=", Go::SLASHEQ),
        ("package_identifier", Go::PackageIdentifier),
        ("const_declaration", Go::ConstDeclaration),
        ("_simple_type", Go::SimpleType),
        ("&&", Go::AMPAMP),
        ("const", Go::Const),
        ("empty_statement", Go::EmptyStatement),
        ("&=", Go::AMPEQ),
        ("<<", Go::LTLT),
        ("%=", Go::PERCENTEQ),
        ("go", Go::Go),
        ("_statement_list_repeat1", Go::StatementListRepeat1),
        ("[", Go::LBRACK),
        ("literal_value", Go::LiteralValue),
        ("{", Go::LBRACE),
        ("=", Go::EQ),
        (",", Go::COMMA),
        ("^", Go::CARET),
        ("var_declaration_repeat1", Go::VarDeclarationRepeat1),
        ("type_conversion_expression", Go::TypeConversionExpression),
        ("call_expression", Go::CallExpression),
        ("type_spec", Go::TypeSpec),
        ("dot", Go::Dot),
        ("case", Go::Case),
        ("channel_type", Go::ChannelType),
        ("type_declaration_repeat1", Go::TypeDeclarationRepeat1),
        ("+=", Go::PLUSEQ),
        ("^=", Go::CARETEQ),
        ("import_spec_list_repeat1", Go::ImportSpecListRepeat1),
        ("-", Go::DASH),
        (">", Go::GT),
        ("func_literal", Go::FuncLiteral),
        ("type_switch_statement", Go::TypeSwitchStatement),
        ("map_type", Go::MapType),
        ("import_declaration", Go::ImportDeclaration),
        ("if_initializer", Go::IfInitializer),
        ("receive_statement", Go::ReceiveStatement),
        ("import_spec", Go::ImportSpec),
        ("_string_literal", Go::StringLiteral),
        ("continue_statement", Go::ContinueStatement),
        ("defer", Go::Defer),
        ("else", Go::Else),
        ("chan", Go::Chan),
        (
            "interpreted_string_literal_repeat1",
            Go::InterpretedStringLiteralRepeat1,
        ),
        ("*=", Go::STAREQ),
        ("|=", Go::PIPEEQ),
        ("parenthesized_type", Go::ParenthesizedType),
        ("label_name", Go::LabelName),
        ("break_statement", Go::BreakStatement),
        ("imaginary_literal", Go::ImaginaryLiteral),
        ("parameter_declaration", Go::ParameterDeclaration),
        ("parenthesized_expression", Go::ParenthesizedExpression),
        ("labeled_statement", Go::LabeledStatement),
        ("_declaration", Go::Declaration),
        ("...", Go::DOTDOTDOT),
        ("<", Go::LT),
        ("type", Go::Type),
        ("==", Go::EQEQ),
        ("||", Go::PIPEPIPE),
        ("default", Go::Default),
        ("method_spec", Go::MethodSpec),
        ("communication_clause", Go::CommunicationClause),
        (
            "expression_switch_statement_repeat1",
            Go::ExpressionSwitchStatementRepeat1,
        ),
        ("implicit_length_array_type", Go::ImplicitLengthArrayType),
        ("expression_case", Go::ExpressionCase),
        ("fallthrough_statement", Go::FallthroughStatement),
        ("&^", Go::AMPCARET),
        ("type_case_clause", Go::TypeCaseClause),
        ("+", Go::PLUS),
        ("field_name_list_repeat1", Go::FieldNameListRepeat1),
        ("field_declaration", Go::FieldDeclaration),
        ("variadic_argument", Go::VariadicArgument),
        ("package", Go::Package),
        ("fallthrough", Go::Fallthrough),
        ("!=", Go::BANGEQ),
        ("}", Go::RBRACE),
        ("parameter_list", Go::ParameterList),
        ("break", Go::Break),
        ("<-", Go::LTDASH),
        ("return", Go::Return),
        (";", Go::SEMI),
        ("interpreted_string_literal", Go::InterpretedStringLiteral),
        ("switch", Go::Switch),
        ("communication_case", Go::CommunicationCase),
        ("const_spec", Go::ConstSpec),
        ("--", Go::DASHDASH),
        ("function_type", Go::FunctionType),
        ("function_declaration", Go::FunctionDeclaration),
        ("const_declaration_repeat1", Go::ConstDeclarationRepeat1),
        ("|", Go::PIPE),
        ("escape_sequence", Go::EscapeSequence),
        ("continue", Go::Continue),
        (">>=", Go::GTGTEQ),
        ("const_spec_repeat1", Go::ConstSpecRepeat1),
        ("++", Go::PLUSPLUS),
        ("pointer_type", Go::PointerType),
        ("var_declaration", Go::VarDeclaration),
        ("type_declaration", Go::TypeDeclaration),
        ("selector_expression", Go::SelectorExpression),
        (
            "type_switch_statement_repeat1",
            Go::TypeSwitchStatementRepeat1,
        ),
        ("go_statement", Go::GoStatement),
        ("parameter_list_repeat1", Go::ParameterListRepeat1),
        ("package_clause", Go::PackageClause),
        (
            "field_declaration_list_repeat1",
            Go::FieldDeclarationListRepeat1,
        ),
        ("literal_value_repeat1", Go::LiteralValueRepeat1),
        ("!", Go::BANG),
        ("for_statement", Go::ForStatement),
        ("int_literal", Go::IntLiteral),
        ("identifier", Go::Identifier),
        ("index_expression", Go::IndexExpression),
        ("_statement", Go::Statement),
        ("source_file_repeat1", Go::SourceFileRepeat1),
        ("expression_switch_statement", Go::ExpressionSwitchStatement),
        ("*", Go::STAR),
        ("slice_type", Go::SliceType),
        ("field_declaration_list", Go::FieldDeclarationList),
        ("type_case", Go::TypeCase),
    ]),
};

impl From<&str> for Go {
    #[inline(always)]
    fn from(key: &str) -> Self {
        KEYS.get(key).unwrap().clone()
    }
}

impl From<u16> for Go {
    #[inline(always)]
    fn from(x: u16) -> Self {
        unsafe { std::mem::transmute(x as u8) }
    }
}

// Go == u16
impl PartialEq<u16> for Go {
    #[inline(always)]
    fn eq(&self, x: &u16) -> bool {
        *self == Go::from(*x)
    }
}

// u16 == Go
impl PartialEq<Go> for u16 {
    #[inline(always)]
    fn eq(&self, x: &Go) -> bool {
        *x == *self
    }
}
